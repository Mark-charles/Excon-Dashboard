"use client"


import React, { useState, useEffect, useCallback, useRef } from 'react'
import { User, Users, Phone, Cpu, MapPin, Tag, ClipboardCheck, Truck, CheckCircle2, XCircle, Clock, Plane, Cog, Package, Volume2, VolumeX, ExternalLink, FileDown } from 'lucide-react'
import ExerciseHeader from '@/components/dashboard/ExerciseHeader'
import ExerciseOverview from '@/components/dashboard/ExerciseOverview'
import * as XLSX from 'xlsx'
import { publishState, subscribeState } from '@/lib/sync'
import { normalizeHeader, downloadCSV } from '@/lib/csv'
import TimelineFilterBar from '@/components/dashboard/TimelineFilterBar'
import Timeline from '@/components/dashboard/Timeline'
import { formatHMS, parseHMS } from '@/lib/time'
import AddInjectForm from '@/components/dashboard/AddInjectForm'
import AddResourceForm from '@/components/dashboard/AddResourceForm'
import ImportInjectsModal from '@/components/dashboard/ImportInjectsModal'
import ImportResourcesModal from '@/components/dashboard/ImportResourcesModal'
import { useDashboardStore } from '@/lib/store'
import { useInjectsImport } from '@/hooks/useInjectsImport'
import { useResourcesImport } from '@/hooks/useResourcesImport'
import { mapInjectType, generateId, renumberInjects } from '@/lib/helpers'
import type { InjectItem, ResourceItem, InjectType, InjectStatus, ResourceStatus, ResourceKind } from '@/lib/types'

// Types moved to '@/lib/types'

const initialInjects: InjectItem[] = []

// Components moved to '@/components/dashboard'

// AddInjectForm, AddResourceForm moved to '@/components/dashboard'

export default function Dashboard() {
  // Exercise info via store
  const exerciseName = useDashboardStore(s => s.exerciseName)
  const setExerciseName = useDashboardStore(s => s.setExerciseName)
  const controllerName = useDashboardStore(s => s.controllerName)
  const setControllerName = useDashboardStore(s => s.setControllerName)
  const exerciseFinishTime = useDashboardStore(s => s.exerciseFinishTime)
  const setExerciseFinishTime = useDashboardStore(s => s.setExerciseFinishTime)
  // Roles + edit lock (local-only). Admin always editable; operators obey edit lock; viewers are read-only.
  const [role, setRole] = useState<string>(() => {
    if (typeof window === 'undefined') return 'admin'
    return localStorage.getItem('excon-role') || 'admin'
  })
  const [editLock, setEditLock] = useState<boolean>(() => {
    if (typeof window === 'undefined') return false
    return (localStorage.getItem('excon-edit-lock') || 'false') === 'true'
  })
  const canEdit = role === 'admin' || (role === 'operator' && !editLock)
  
  // Stable callback functions for ExerciseHeader
  const handleExerciseNameChange = useCallback((value: string) => {
    setExerciseName(value)
  }, [setExerciseName])
  
  const handleControllerNameChange = useCallback((value: string) => {
    setControllerName(value)
  }, [setControllerName])
  
  const handleFinishTimeChange = useCallback((value: string) => {
    setExerciseFinishTime(value)
  }, [setExerciseFinishTime])
  
  // Stable callback functions for forms are defined after their dependencies below
  
  // Timer and main state
  const currentSeconds = useDashboardStore(s => s.currentSeconds)
  const isRunning = useDashboardStore(s => s.isRunning)
  const start = useDashboardStore(s => s.start)
  const stop = useDashboardStore(s => s.stop)
  const resetTimer = useDashboardStore(s => s.reset)
  const setSeconds = useDashboardStore(s => s.setSeconds)
  const tick = useDashboardStore(s => s.tick)
  const injects = useDashboardStore(s => s.injects)
  const setInjects = useDashboardStore(s => s.setInjects)
  const resources = useDashboardStore(s => s.resources)
  const setResources = useDashboardStore(s => s.setResources)
  const [audioEnabled, setAudioEnabled] = useState<boolean>(() => {
    if (typeof window === 'undefined') return true
    const raw = localStorage.getItem('excon-audio-enabled')
    return raw ? raw === 'true' : true
  })
  const alertedDueRef = useRef<Set<string>>(new Set())
  const alertedMissedRef = useRef<Set<string>>(new Set())
  const prevInjectsRef = useRef<InjectItem[] | null>(null)
  const externalUpdateRef = useRef(false)
  const scenarioFileInputRef = useRef<HTMLInputElement | null>(null)
  const [toast, setToast] = useState<{message: string; ts: number} | null>(null)
  const toastTimeoutRef = useRef<number | null>(null)
  
  // Shared focus-visible ring style for accessibility
  const focusRing = "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-blue-400 ring-offset-gray-800"

  // Local persistence of key state (hydrate store)
  useEffect(() => {
    try {
      const raw = typeof window !== 'undefined' ? localStorage.getItem('excon-dashboard-state-v1') : null
      if (!raw) return
      const parsed = JSON.parse(raw)
      if (parsed && typeof parsed === 'object') {
        if (typeof parsed.exerciseName === 'string') setExerciseName(parsed.exerciseName)
        if (typeof parsed.controllerName === 'string') setControllerName(parsed.controllerName)
        if (typeof parsed.exerciseFinishTime === 'string') setExerciseFinishTime(parsed.exerciseFinishTime)
        if (Array.isArray(parsed.injects)) setInjects(parsed.injects as InjectItem[])
        if (Array.isArray(parsed.resources)) setResources(parsed.resources as ResourceItem[])
        if (typeof parsed.currentSeconds === 'number' && parsed.currentSeconds >= 0) setSeconds(parsed.currentSeconds)
      }
    } catch {}
  }, [])

  useEffect(() => {
    try {
      const state = {
        exerciseName,
        controllerName,
        exerciseFinishTime,
        currentSeconds,
        injects,
        resources,
      }
      if (typeof window !== 'undefined') {
        if (externalUpdateRef.current) {
          // Skip publish for externally-driven updates to avoid loops
          externalUpdateRef.current = false
        } else {
          publishState(state)
        }
        localStorage.setItem('excon-dashboard-state-v1', JSON.stringify(state))
      }
    } catch {}
  }, [exerciseName, controllerName, exerciseFinishTime, currentSeconds, injects, resources])

  // Subscribe to external state updates (e.g., Admin page changes)
  useEffect(() => {
    const unsub = subscribeState((s) => {
      externalUpdateRef.current = true
      const detailsChanged = (typeof s.exerciseName === 'string' && s.exerciseName !== exerciseName)
        || (typeof s.controllerName === 'string' && s.controllerName !== controllerName)
        || (typeof s.exerciseFinishTime === 'string' && s.exerciseFinishTime !== exerciseFinishTime)
      const injectsChanged = Array.isArray(s.injects) && JSON.stringify(s.injects) !== JSON.stringify(injects)
      const resourcesChanged = Array.isArray(s.resources) && JSON.stringify(s.resources) !== JSON.stringify(resources)
      if (typeof s.exerciseName === 'string') setExerciseName(s.exerciseName)
      if (typeof s.controllerName === 'string') setControllerName(s.controllerName)
      if (typeof s.exerciseFinishTime === 'string') setExerciseFinishTime(s.exerciseFinishTime)
      if (typeof s.currentSeconds === 'number') setSeconds(s.currentSeconds)
      if (Array.isArray(s.injects)) setInjects(s.injects as InjectItem[])
      if (Array.isArray(s.resources)) setResources(s.resources as ResourceItem[])

      // Show a small toast when changes arrive from Admin
      const showToast = (message: string) => {
        setToast({ message, ts: Date.now() })
        if (toastTimeoutRef.current) window.clearTimeout(toastTimeoutRef.current)
        toastTimeoutRef.current = window.setTimeout(() => setToast(null), 3000)
      }
      if (detailsChanged) showToast('Exercise details updated')
      else if (injectsChanged || resourcesChanged) showToast('Scenario updated')
    })
    return () => unsub()
  }, [])

  // Listen for role/lock changes via storage (e.g., Admin page)
  useEffect(() => {
    const onStorage = (e: StorageEvent) => {
      if (e.key === "excon-role") setRole(localStorage.getItem("excon-role") || "admin")
      if (e.key === "excon-edit-lock") setEditLock((localStorage.getItem("excon-edit-lock") || "false") === "true")
    }
    if (typeof window !== "undefined") window.addEventListener("storage", onStorage)
    return () => { if (typeof window !== "undefined") window.removeEventListener("storage", onStorage) }
  }, [])


  

  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('excon-audio-enabled', String(audioEnabled))
    }
  }, [audioEnabled])
  
  // Import hooks (injects/resources)
  const injectImport = useInjectsImport({ currentSeconds, injects, setInjects })
  const resourceImport = useResourcesImport({ currentSeconds, resources, setResources })
  const [autoAdvanceResources, setAutoAdvanceResources] = useState<boolean>(() => {
    if (typeof window === 'undefined') return false
    const raw = localStorage.getItem('excon-auto-advance-resources')
    return raw ? raw === 'true' : false
  })

  // Snooze modal state
  const [snoozeInjectId, setSnoozeInjectId] = useState<string | null>(null)
  const [snoozeInput, setSnoozeInput] = useState<string>('')

  // Persist auto-advance toggle
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('excon-auto-advance-resources', String(autoAdvanceResources))
    }
  }, [autoAdvanceResources])

  // Auto-advance resources when enabled
  useEffect(() => {
    if (!autoAdvanceResources) return
    setResources(prev => prev.map(r => {
      const created = r.createdAtSeconds ?? 0
      if (r.status === 'requested' && currentSeconds - created >= 60) {
        return { ...r, status: 'tasked' as const }
      }
      if (r.status === 'tasked' && currentSeconds >= (r.etaSeconds - 60)) {
        return { ...r, status: 'enroute' as const }
      }
      return r
    }))
  }, [currentSeconds, autoAdvanceResources])

  // Inline editing state
  const [editingField, setEditingField] = useState<{id: string, field: string} | null>(null)
  const [editingValue, setEditingValue] = useState<string>('')

  // Filter state
  const [showInjects, setShowInjects] = useState(true)
  const [showResources, setShowResources] = useState(true)
  const [showInPerson, setShowInPerson] = useState(true)
  const [showRadioPhone, setShowRadioPhone] = useState(true)
  const [showElectronic, setShowElectronic] = useState(true)
  const [showMapInject, setShowMapInject] = useState(true)
  const [showOther, setShowOther] = useState(true)
  const [showRequestedStatus, setShowRequestedStatus] = useState(true)
  const [showTaskedStatus, setShowTaskedStatus] = useState(true)
  const [showEnrouteStatus, setShowEnrouteStatus] = useState(true)
  const [showArrivedStatus, setShowArrivedStatus] = useState(true)
  const [showCancelledStatus, setShowCancelledStatus] = useState(true)

  useEffect(() => {
    let intervalId: NodeJS.Timeout | null = null
    if (isRunning) {
      intervalId = setInterval(() => { tick() }, 1000)
    }
    return () => { if (intervalId) clearInterval(intervalId) }
  }, [isRunning, tick])

  // Auto-check for missed injects
  useEffect(() => {
    setInjects(prevInjects => 
      prevInjects.map(inject => 
        inject.status === "pending" && currentSeconds > inject.dueSeconds
          ? { ...inject, status: "missed" as const }
          : inject
      )
    )
  }, [currentSeconds])

  // Detect newly due and newly missed injects for audio cues
  useEffect(() => {
    if (!audioEnabled) return
    // Single beep when an inject becomes due (once)
    injects.forEach(inject => {
      if (inject.status === 'pending' && currentSeconds >= inject.dueSeconds && !alertedDueRef.current.has(inject.id)) {
        alertedDueRef.current.add(inject.id)
        if (!inject.acked) {
          if (inject.audioDataUrl && inject.autoPlayAudio) {
            try {
              const audio = new Audio(inject.audioDataUrl)
              void audio.play()
            } catch { /* ignore */ }
          } else {
            playBeep(1)
          }
        }
      }
    })
  }, [currentSeconds, injects, audioEnabled])

  useEffect(() => {
    if (!audioEnabled) {
      prevInjectsRef.current = injects
      return
    }
    const prev = prevInjectsRef.current
    if (prev) {
      const prevStatus = new Map(prev.map(i => [i.id, i.status]))
      injects.forEach(i => {
        const was = prevStatus.get(i.id)
        if (i.status === 'missed' && was !== 'missed' && !alertedMissedRef.current.has(i.id)) {
          alertedMissedRef.current.add(i.id)
          playBeep(2)
        }
      })
    }
    prevInjectsRef.current = injects
  }, [injects, audioEnabled])

  const playBeep = (times: number) => {
    try {
      const AudioCtx = (window as any).AudioContext || (window as any).webkitAudioContext
      if (!AudioCtx) return
      const ctx = new AudioCtx()
      const duration = 0.12
      const gap = 0.12
      for (let n = 0; n < times; n++) {
        const osc = ctx.createOscillator()
        const gain = ctx.createGain()
        osc.type = 'sine'
        osc.frequency.value = times === 2 ? 880 : 660
        osc.connect(gain)
        gain.connect(ctx.destination)
        const start = ctx.currentTime + n * (duration + gap)
        const end = start + duration
        gain.gain.setValueAtTime(0.0001, start)
        gain.gain.exponentialRampToValueAtTime(0.2, start + 0.01)
        gain.gain.exponentialRampToValueAtTime(0.0001, end)
        osc.start(start)
        osc.stop(end)
      }
      // close after a short delay to free resources
      setTimeout(() => ctx.close(), (duration + gap) * times * 1000 + 200)
    } catch {}
  }

  useEffect(() => {
    setResources(prevResources => 
      prevResources.map(resource => {
        // Auto-advance enroute -> arrived at ETA
        if (resource.status === "enroute" && currentSeconds >= resource.etaSeconds) {
          return { ...resource, status: "arrived" as const }
        }
        return resource
      })
    )
  }, [currentSeconds])

  // formatHMS/parseHMS imported from '@/lib/time'



  const getInjectStatusColor = (status: InjectStatus): string => {
    switch (status) {
      case "pending": return "bg-gray-500 text-white"
      case "completed": return "bg-green-500 text-white"
      case "missed": return "bg-red-500 text-white"
      case "skipped": return "bg-orange-500 text-white"
      default: return "bg-gray-500 text-white"
    }
  }


  const getInjectTypeColor = (type: InjectType): string => {
    switch (type) {
      case "in person": return "bg-blue-500"
      case "radio/phone": return "bg-green-500"
      case "electronic": return "bg-purple-500"
      case "map inject": return "bg-red-500"
      case "other": return "bg-orange-500"
      default: return "bg-gray-500"
    }
  }
const getInjectTypeTextColor = (type: InjectType): string => {
    switch (type) {
      case "in person": return "text-blue-400"
      case "radio/phone": return "text-green-400"
      case "electronic": return "text-purple-400"
      case "map inject": return "text-red-400"
      case "other": return "text-orange-400"
      default: return "text-gray-400"
    }
  }

  const getResourceStatusTextColor = (status: ResourceStatus): string => {
    switch (status) {
      case "requested": return "text-gray-400"
      case "tasked": return "text-amber-400"
      case "enroute": return "text-blue-400"
      case "arrived": return "text-green-400"
      case "cancelled": return "text-red-400"
      default: return "text-gray-400"
    }
  }

  // Icon helpers (SVG components via lucide-react)
  const getInjectTypeIcon = (type: InjectType) => {
    const props = { size: 16, className: "inline align-middle" }
    switch (type) {
      case 'in person': return <User {...props} />
      case 'radio/phone': return <Phone {...props} />
      case 'electronic': return <Cpu {...props} />
      case 'map inject': return <MapPin {...props} />
      case 'other': return <Tag {...props} />
      default: return <Tag {...props} />
    }
  }

  const getResourceStatusIcon = (status: ResourceStatus) => {
    const props = { size: 16, className: "inline align-middle" }
    switch (status) {
      case 'requested': return <Clock {...props} />
      case 'tasked': return <ClipboardCheck {...props} />
      case 'enroute': return <Truck {...props} />
      case 'arrived': return <CheckCircle2 {...props} />
      case 'cancelled': return <XCircle {...props} />
      default: return <Tag {...props} />
    }
  }


  const getResourceKindIcon = (kind?: ResourceKind) => {
    const props = { size: 16, className: "inline align-middle" }
    switch (kind) {
      case 'person': return <User {...props} />
      case 'vehicle': return <Truck {...props} />
      case 'group': return <Users {...props} />
      case 'air': return <Plane {...props} />
      case 'capability': return <Cog {...props} />
      case 'supply': return <Package {...props} />
      default: return <Truck {...props} />
    }
  }
  const isCurrentInject = (inject: InjectItem): boolean => {
    const timeDiff = Math.abs(currentSeconds - inject.dueSeconds)
    return timeDiff <= 30
  }

  // Import helper functions moved to '@/lib/csv'

  // mapInjectType, generateId moved to '@/lib/helpers'



  // Resource helper functions
  const getResourceStatusColor = (status: ResourceStatus): string => {
    switch (status) {
      case "requested": return "bg-gray-500 text-white"
      case "tasked": return "bg-amber-500 text-white"
      case "enroute": return "bg-blue-600 text-white"
      case "arrived": return "bg-green-500 text-white"
      case "cancelled": return "bg-red-500 text-white"
      default: return "bg-gray-500 text-white"
    }
  }


  const isTerminalStatus = (status: ResourceStatus): boolean => {
    return status === "arrived" || status === "cancelled"
  }

  const canTransitionTo = (currentStatus: ResourceStatus, targetStatus: ResourceStatus): boolean => {
    if (isTerminalStatus(currentStatus)) return false
    
    switch (currentStatus) {
      case "requested": return targetStatus === "tasked" || targetStatus === "cancelled"
      case "tasked": return targetStatus === "enroute" || targetStatus === "cancelled"
      case "enroute": return targetStatus === "arrived" || targetStatus === "cancelled"
      default: return false
    }
  }

  // Timer handlers
  const handleStartStop = () => {
    if (isRunning) stop(); else start()
  }

  const handleReset = () => {
    resetTimer()
  }

  const handleManualTimeSet = (timeInput: string) => {
    const parsedSeconds = parseHMS(timeInput)
    if (parsedSeconds !== null) {
      setSeconds(parsedSeconds)
    }
  }

  // Inject status handlers
  const handleToggleInjectStatus = (injectId: string) => {
    setInjects(prevInjects => 
      prevInjects.map(inject => 
        inject.id === injectId 
          ? { ...inject, status: inject.status === "completed" ? "pending" as const : "completed" as const }
          : inject
      )
    )
  }

  const handleAckInject = (injectId: string, ack: boolean) => {
    setInjects(prev => prev.map(i => i.id === injectId ? { ...i, acked: ack } : i))
  }

  const handleSnoozeInject = (injectId: string, minutes: number) => {
    const offset = Math.max(0, Math.round(minutes * 60))
    setInjects(prev => renumberInjects(prev.map(i => i.id === injectId ? { ...i, dueSeconds: currentSeconds + offset, acked: false } : i)))
    alertedDueRef.current.delete(injectId)
  }

  const handlePlayInjectAudio = (injectId: string) => {
    const inject = injects.find(i => i.id === injectId)
    if (inject?.audioDataUrl) {
      try {
        const audio = new Audio(inject.audioDataUrl)
        void audio.play()
      } catch {}
    }
  }

  // Resource handlers
  const handleResourceStatusChange = (resourceId: string, newStatus: ResourceStatus) => {
    setResources(prevResources => 
      prevResources.map(resource => 
        resource.id === resourceId && canTransitionTo(resource.status, newStatus)
          ? { ...resource, status: newStatus }
          : resource
      )
    )
  }

  const handleResourceETAEdit = (resourceId: string, newETATime: string) => {
    let newETASeconds: number | null = null
    const val = newETATime.trim()
    if (/^\d{1,2}:\d{1,2}:\d{1,2}$/.test(val)) {
      newETASeconds = parseHMS(val)
    } else {
      const num = Number(val)
      if (!isNaN(num) && num >= 0) {
        // treat numeric as minutes from now
        newETASeconds = currentSeconds + Math.round(num * 60)
      }
    }
    if (newETASeconds !== null) {
      setResources(prevResources =>
        prevResources.map(resource =>
          resource.id === resourceId
            ? { ...resource, etaSeconds: newETASeconds }
            : resource
        )
      )
    }
  }




  // Form handlers
  // renumberInjects moved to '@/lib/helpers'

  const handleAddInject = useCallback((title: string, dueTime: string, type: InjectType, to: string, from: string, audioDataUrl?: string, audioName?: string, autoPlayAudio?: boolean) => {
    const dueSeconds = parseHMS(dueTime)
    if (dueSeconds !== null && title.trim() && to.trim() && from.trim()) {
      const newInject: InjectItem = {
        id: `i${Date.now()}`,
        number: 1, // Temporary number, will be renumbered
        title: title.trim(),
        dueSeconds,
        type,
        status: "pending",
        to: to.trim(),
        from: from.trim(),
        acked: false,
        audioDataUrl,
        audioName,
        autoPlayAudio: !!autoPlayAudio
      }
      setInjects(prev => renumberInjects([...prev, newInject]))
    }
  }, [renumberInjects])

  // Inject management functions
  const handleDeleteInject = (id: string) => {
    setInjects(prev => renumberInjects(prev.filter(inject => inject.id !== id)))
  }

  const handleSkipInject = (id: string) => {
    setInjects(prev => 
      prev.map(inject => 
        inject.id === id 
          ? { ...inject, status: "skipped" as const }
          : inject
      )
    )
  }

  const handleMoveInject = (id: string, direction: 'up' | 'down') => {
    setInjects(prev => {
      const sorted = [...prev].sort((a, b) => a.dueSeconds - b.dueSeconds)
      const index = sorted.findIndex(inject => inject.id === id)
      
      if (index === -1) return prev
      if (direction === 'up' && index === 0) return prev
      if (direction === 'down' && index === sorted.length - 1) return prev
      
      const newIndex = direction === 'up' ? index - 1 : index + 1
      const targetInject = sorted[newIndex]
      
      // Swap due times to maintain order
      const currentInject = sorted[index]
      const newDueSeconds = targetInject.dueSeconds
      const targetNewDueSeconds = currentInject.dueSeconds
      
      return renumberInjects(prev.map(inject => {
        if (inject.id === id) return { ...inject, dueSeconds: newDueSeconds }
        if (inject.id === targetInject.id) return { ...inject, dueSeconds: targetNewDueSeconds }
        return inject
      }))
    })
  }

  // Inline editing functions
  const handleStartEdit = (id: string, field: string, currentValue: string | number) => {
    if (!canEdit) return
    setEditingField({ id, field })
    setEditingValue(String(currentValue))
  }

  const handleCancelEdit = () => {
    setEditingField(null)
    setEditingValue('')
  }

  const handleSaveEdit = () => {
    if (!editingField) return

    const { id, field } = editingField
    const value = editingValue.trim()

    setInjects(prev => {
      const updated = prev.map(inject => {
        if (inject.id !== id) return inject

        switch (field) {
          case 'number': {
            const newNumber = parseInt(value)
            if (isNaN(newNumber) || newNumber < 1) return inject
            return { ...inject, number: newNumber }
          }
          case 'dueTime': {
            const dueSeconds = parseHMS(value)
            if (dueSeconds === null) return inject
            return { ...inject, dueSeconds }
          }
          case 'title':
            if (!value) return inject
            return { ...inject, title: value }
          case 'type':
            if (!['in person', 'radio/phone', 'electronic', 'map inject', 'other'].includes(value)) return inject
            return { ...inject, type: value as InjectType }
          case 'to':
            return { ...inject, to: value }
          case 'from':
            return { ...inject, from: value }
          default:
            return inject
        }
      })

      // Re-number based on due time order if time or number was changed
      if (field === 'dueTime') {
        return renumberInjects(updated)
      }
      return updated
    })

    setEditingField(null)
    setEditingValue('')
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSaveEdit()
    } else if (e.key === 'Escape') {
      handleCancelEdit()
    }
  }

  const handleAddResource = useCallback((label: string, etaMinutes: number, kind: ResourceKind) => {
    if (label.trim() && etaMinutes >= 0) {
      const newResource: ResourceItem = {
        id: `r${Date.now()}`,
        label: label.trim(),
        etaSeconds: currentSeconds + (etaMinutes * 60),
        status: "requested",
        kind,
        createdAtSeconds: currentSeconds
      }
      setResources(prev => [...prev, newResource])
    }
  }, [currentSeconds])

  // Stable callback functions for forms (defined after their dependencies to avoid TDZ)
  const handleAddInjectCallback = useCallback((
    title: string,
    dueTime: string,
    type: InjectType,
    to: string,
    from: string,
    audioDataUrl?: string | null,
    audioName?: string | null,
    autoPlayAudio?: boolean,
  ) => {
    handleAddInject(title, dueTime, type, to, from, audioDataUrl || undefined, audioName || undefined, !!autoPlayAudio)
  }, [handleAddInject])

  const handleAddResourceCallback = useCallback((label: string, minutes: number, kind: ResourceKind) => {
    handleAddResource(label, minutes, kind)
  }, [handleAddResource])

  const handleImportClickCallback = useCallback(() => {
    if (!canEdit) return
    injectImport.setOpen(true)
  }, [canEdit, injectImport])

  const handleResourceImportClickCallback = useCallback(() => {
    if (!canEdit) return
    resourceImport.setOpen(true)
  }, [canEdit, resourceImport])

  // Import handlers

  // Scenario templates (JSON)
  const saveScenarioJSON = () => {
    try {
      const scenario = {
        version: 'excon-scenario-v1',
        exerciseName,
        controllerName,
        exerciseFinishTime,
        injects: [...injects]
          .sort((a,b) => a.dueSeconds - b.dueSeconds)
          .map(i => ({ title: i.title, dueSeconds: i.dueSeconds, type: i.type, to: i.to, from: i.from })),
        resources: [...resources]
          .sort((a,b) => a.etaSeconds - b.etaSeconds)
          .map(r => ({ label: r.label, etaSeconds: r.etaSeconds, status: r.status, kind: r.kind }))
      }
      const blob = new Blob([JSON.stringify(scenario, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      const name = exerciseName?.trim() ? `_${exerciseName.trim().replace(/\s+/g,'_')}` : ''
      a.href = url
      a.download = `scenario${name}.json`
      document.body.appendChild(a)
      a.click()
      a.remove()
      URL.revokeObjectURL(url)
    } catch {}
  }

  const handleScenarioLoad = async (file: File) => {
    try {
      const text = await file.text()
      const data = JSON.parse(text)
      if (!data || typeof data !== 'object' || data.version !== 'excon-scenario-v1') return
      // Basic shape checks
      const loadedInjects: InjectItem[] = Array.isArray(data.injects) ? data.injects.map((i: any, idx: number) => ({
        id: generateId(),
        number: idx + 1,
        title: String(i.title || ''),
        dueSeconds: Number(i.dueSeconds || 0),
        type: mapInjectType(String(i.type || 'other')),
        status: 'pending',
        to: String(i.to || ''),
        from: String(i.from || '')
      })) : []

      const loadedResources: ResourceItem[] = Array.isArray(data.resources) ? data.resources.map((r: any) => ({
        id: generateId(),
        label: String(r.label || ''),
        etaSeconds: Number(r.etaSeconds || 0),
        status: (['requested','tasked','enroute','arrived','cancelled'].includes(String(r.status))) ? r.status as ResourceStatus : 'requested',
        kind: (['person','vehicle','group','air','capability','supply'].includes(String(r.kind))) ? r.kind as any : undefined,
      })) : []

      setInjects(renumberInjects(loadedInjects))
      setResources(loadedResources)
      if (typeof data.exerciseName === 'string') setExerciseName(data.exerciseName)
      if (typeof data.controllerName === 'string') setControllerName(data.controllerName)
      if (typeof data.exerciseFinishTime === 'string') setExerciseFinishTime(data.exerciseFinishTime)
    } catch {}
  }

  // CSV export helpers moved to '@/lib/csv'
  const exportInjectsImportCSV = () => {
    const rows: (string|number)[][] = []
    rows.push(['Title','Due (minutes)','Type','To','From'])
    const sorted = [...injects].sort((a,b) => a.dueSeconds - b.dueSeconds)
    sorted.forEach(i => {
      const minutes = Math.max(0, Math.round((i.dueSeconds - currentSeconds) / 60))
      rows.push([i.title, minutes, i.type, i.to, i.from])
    })
    const name = exerciseName?.trim() ? `_${exerciseName.trim().replace(/\s+/g,'_')}` : ''
    downloadCSV(`injects_import${name}.csv`, rows)
  }
  const exportResourcesCSV = () => {
    const rows: (string|number)[][] = []
    rows.push(['Label','Status','Kind','ETASeconds','ETA(HH:MM:SS)'])
    const sorted = [...resources].sort((a,b) => a.etaSeconds - b.etaSeconds)
    sorted.forEach(r => rows.push([r.label, r.status, r.kind || '', r.etaSeconds, formatHMS(r.etaSeconds)]))
    const name = exerciseName?.trim() ? `_${exerciseName.trim().replace(/\s+/g,'_')}` : ''
    downloadCSV(`resources${name}.csv`, rows)
  }



  // Resource import handlers


  const downloadResourceTemplate = () => {
    const templateData = [
      ['Label', 'Kind (optional)', 'ETA (minutes)', 'Status'],
      ['Fire Engine 1', 'vehicle', '15', 'requested'],
      ['Ambulance 2', 'vehicle', '20', 'requested'],
      ['Police Unit 3', 'vehicle', '10', 'requested'],
      ['Hazmat Team', 'group', '45', 'requested']
    ]
    
    const worksheet = XLSX.utils.aoa_to_sheet(templateData)
    const workbook = XLSX.utils.book_new()
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Resources Template')
    // Explicitly write CSV to avoid inference issues on some browsers
    XLSX.writeFile(workbook, 'resources_template.csv', { bookType: 'csv' })
  }

  // Internal Components

  const TimerControls = () => {
    const [manualTime, setManualTime] = useState('')

    const handleManualSubmit = (e: React.FormEvent) => {
      e.preventDefault()
      if (manualTime.trim()) {
        handleManualTimeSet(manualTime.trim())
        setManualTime('')
      }
    }

    return (
      <div className="bg-gray-800 rounded-lg p-6">
        <div className="flex items-start justify-end mb-2">
          <button
            onClick={() => { if (typeof window !== 'undefined') window.open('/display/timer', 'TimerDisplay', 'noopener,noreferrer,width=900,height=700'); }}
            className="p-2 rounded bg-gray-700 hover:bg-gray-600 text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-400 focus-visible:ring-offset-2 ring-offset-gray-800"
            title="Open Timer Display"
            aria-label="Open Timer Display"
          >
            <ExternalLink className="w-4 h-4" />
          </button>
        </div>
        <div className="text-center mb-6">
          <div className="text-5xl md:text-7xl xl:text-8xl font-mono font-bold text-white mb-4 tracking-wider">
            {formatHMS(currentSeconds)}
          </div>
          <div className="flex gap-4 justify-center mb-4">
            <button
              onClick={handleStartStop}
              className="px-6 py-3 text-xl font-semibold rounded-lg transition-colors bg-blue-600 hover:bg-blue-700 text-white min-w-[120px] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-blue-400 ring-offset-gray-800"
            >
              {isRunning ? 'Stop' : 'Start'}
            </button>
            
            <button
              onClick={handleReset}
              className="px-6 py-3 text-xl font-semibold rounded-lg transition-colors bg-red-600 hover:bg-red-700 text-white min-w-[120px] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-blue-400 ring-offset-gray-800"
            >
              Reset
            </button>
          </div>
          <form onSubmit={handleManualSubmit} className="flex gap-2 justify-center">
            <input
              type="text"
              placeholder="HH:MM:SS"
              value={manualTime}
              onChange={(e) => setManualTime(e.target.value)}
              className="px-3 py-2 bg-gray-700 text-white rounded font-mono text-center w-32 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-400 focus-visible:ring-offset-2 ring-offset-gray-800"
            />
            <button
              type="submit"
              className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded font-semibold"
            >
              Set
            </button>
          </form>
        </div>
      </div>
    )
  }


  // Editable field component
  const EditableField = ({ 
    inject, 
    field, 
    value, 
    displayValue, 
    isSelect = false, 
    selectOptions = [] 
  }: {
    inject: InjectItem
    field: string
    value: string | number
    displayValue?: string
    isSelect?: boolean
    selectOptions?: string[]
  }) => {
    const isEditing = editingField?.id === inject.id && editingField?.field === field
    
    if (isEditing) {
      if (isSelect) {
        return (
          <select
            value={editingValue}
            onChange={(e) => setEditingValue(e.target.value)}
            onBlur={handleSaveEdit}
            onKeyDown={handleKeyPress}
            className="w-full px-2 py-1 bg-gray-700 text-white text-sm rounded border border-blue-500"
            autoFocus
          >
            {selectOptions.map(option => (
              <option key={option} value={option}>{option}</option>
            ))}
          </select>
        )
      }
      
      return (
        <input
          type="text"
          value={editingValue}
          onChange={(e) => setEditingValue(e.target.value)}
          onBlur={handleSaveEdit}
          onKeyDown={handleKeyPress}
          className="w-full px-2 py-1 bg-gray-700 text-white text-sm rounded border border-blue-500"
          autoFocus
        />
      )
    }
    
    const onKey = (e: React.KeyboardEvent) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault()
        handleStartEdit(inject.id, field, value)
      }
    }
    const fieldLabel: Record<string, string> = {
      number: 'number', dueTime: 'due time', title: 'title', type: 'type', to: 'to', from: 'from'
    }
    return (
      <div
        role="button"
        tabIndex={0}
        onClick={() => handleStartEdit(inject.id, field, value)}
        onKeyDown={onKey}
        className="cursor-pointer hover:bg-gray-700 hover:bg-opacity-50 px-2 py-1 rounded transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-400 focus-visible:ring-offset-2 ring-offset-gray-800"
        title="Click to edit"
        aria-label={`Edit ${fieldLabel[field] || field} for inject #${inject.number}`}
      >
        {displayValue || value}
      </div>
    )
  }

  const InjectList = () => {
    return (
      <div className="bg-gray-800 rounded-lg p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-2xl font-bold text-white">Inject Status</h3>
          <div className="flex items-center gap-2">
            <button
              onClick={exportInjectsImportCSV}
              className="p-2 rounded bg-gray-700 hover:bg-gray-600 text-white"
              title="Export Injects (Import CSV)"
              aria-label="Export Injects (Import CSV)"
            >
              <FileDown className="w-4 h-4" />
            </button>
            <button
              onClick={() => setAudioEnabled(v => !v)}
              className="p-2 rounded bg-gray-700 hover:bg-gray-600 text-white"
              title={audioEnabled ? 'Mute alerts' : 'Unmute alerts'}
              aria-pressed={audioEnabled}
              aria-label={audioEnabled ? 'Mute audio alerts' : 'Unmute audio alerts'}
            >
              {audioEnabled ? <Volume2 className="w-4 h-4" /> : <VolumeX className="w-4 h-4" />}
            </button>
          </div>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full" aria-label="Injects table">
            <thead className="bg-gray-700">
              <tr>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">#</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Due Time</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">From</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">To</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Type</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Title</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Status</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Actions</th>
              </tr>
            </thead>
            <tbody>
              {[...injects].sort((a, b) => a.dueSeconds - b.dueSeconds).map((inject, sortedIndex) => (
                <tr 
                  key={inject.id} 
                  className={`border-t border-gray-600 ${
                    isCurrentInject(inject) ? 'bg-yellow-900 bg-opacity-30' : ''
                  } ${inject.status === 'skipped' ? 'opacity-60' : ''}`}
                >
                  <td className="px-4 py-3 text-sm font-mono text-white font-semibold">
                    <EditableField
                      inject={inject}
                      field="number"
                      value={inject.number}
                      displayValue={`#${inject.number}`}
                    />
                  </td>
                  <td className="px-4 py-3 text-sm font-mono text-white">
                    <EditableField
                      inject={inject}
                      field="dueTime"
                      value={formatHMS(inject.dueSeconds)}
                      displayValue={formatHMS(inject.dueSeconds)}
                    />
                  </td>
                  <td className="px-4 py-3 text-sm text-white">
                    <EditableField
                      inject={inject}
                      field="from"
                      value={inject.from || ''}
                      displayValue={inject.from || '-'}
                    />
                  </td>
                  <td className="px-4 py-3 text-sm text-white">
                    <EditableField
                      inject={inject}
                      field="to"
                      value={inject.to || ''}
                      displayValue={inject.to || '-'}
                    />
                  </td>
                  <td className="px-4 py-3">
                    {editingField?.id === inject.id && editingField?.field === 'type' ? (
                      <select
                        value={editingValue}
                        onChange={(e) => setEditingValue(e.target.value)}
                        onBlur={handleSaveEdit}
                        onKeyDown={handleKeyPress}
                        className="w-full px-2 py-1 bg-gray-700 text-white text-sm rounded border border-blue-500"
                        autoFocus
                      >
                        <option value="in person">in person</option>
                        <option value="radio/phone">radio/phone</option>
                        <option value="electronic">electronic</option>
                        <option value="map inject">map inject</option>
                        <option value="other">other</option>
                      </select>
                    ) : (
                      <div
                        onClick={() => handleStartEdit(inject.id, 'type', inject.type)}
                        className="cursor-pointer hover:bg-gray-700 hover:bg-opacity-50 px-2 py-1 rounded transition-colors"
                        title="Click to edit"
                      >
                        <span className={`px-2 py-1 rounded-full text-xs font-semibold capitalize ${getInjectTypeColor(inject.type)}`}>
                          {inject.type}
                        </span>
                      </div>
                    )}
                  </td>
                  <td className={`px-4 py-3 text-sm text-white ${inject.status === 'skipped' ? 'line-through' : ''}`}>
                    <EditableField
                      inject={inject}
                      field="title"
                      value={inject.title}
                      displayValue={inject.title}
                    />
                  </td>
                  <td className="px-4 py-3">
                    <span className={`px-2 py-1 rounded-full text-xs font-semibold capitalize ${getInjectStatusColor(inject.status)}`}>
                      {inject.status}
                    </span>
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex gap-1">
                      {/* Ack */}
                      <button
                        onClick={() => handleAckInject(inject.id, !(inject.acked ?? false))}
                        className={`px-2 py-1 text-xs ${inject.acked ? 'bg-gray-600' : 'bg-teal-600 hover:bg-teal-700'} text-white rounded ${focusRing}`}
                        disabled={!canEdit}
                        title={inject.acked ? 'Unacknowledge' : 'Acknowledge'}
                        aria-label={inject.acked ? `Unacknowledge inject #${inject.number}` : `Acknowledge inject #${inject.number}`}
                      >
                        {inject.acked ? 'Unack' : 'Ack'}
                      </button>
                      {/* Snooze */}
                      <button
                        onClick={() => setSnoozeInjectId(inject.id)}
                        className={`px-2 py-1 text-xs bg-purple-700 hover:bg-purple-600 text-white rounded ${focusRing}`}
                        title="Snooze (custom)"
                        aria-label={`Snooze inject #${inject.number}`}
                        disabled={!canEdit}
                      >
                        Snooze
                      </button>
                      <button
                        onClick={() => handleSnoozeInject(inject.id, 5)}
                        className={`px-2 py-1 text-xs bg-purple-600 hover:bg-purple-700 text-white rounded ${focusRing}`}
                        title="Snooze +5m"
                        aria-label={`Snooze inject #${inject.number} by 5 minutes`}
                        disabled={!canEdit}
                      >
                        +5m
                      </button>
                      <button
                        onClick={() => handleSnoozeInject(inject.id, 10)}
                        className={`px-2 py-1 text-xs bg-purple-600 hover:bg-purple-700 text-white rounded ${focusRing}`}
                        title="Snooze +10m"
                        aria-label={`Snooze inject #${inject.number} by 10 minutes`}
                        disabled={!canEdit}
                      >
                        +10m
                      </button>
                      {inject.audioDataUrl && (
                        <button
                          onClick={() => handlePlayInjectAudio(inject.id)}
                          className={`px-2 py-1 text-xs bg-indigo-600 hover:bg-indigo-700 text-white rounded ${focusRing}`}
                          title="Play attached audio"
                          aria-label={`Play audio for inject #${inject.number}`}
                        >
                          Play
                        </button>
                      )}
                      {/* Move Up/Down */}
                      <button
                        onClick={() => handleMoveInject(inject.id, 'up')}
                        disabled={!canEdit || sortedIndex === 0}
                        className={`px-2 py-1 text-xs bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:opacity-50 text-white rounded ${focusRing}`}
                        title="Move up"
                        aria-label={`Move inject #${inject.number} up`}
                      >
                        Up
                      </button>
                      <button
                        onClick={() => handleMoveInject(inject.id, 'down')}
                        disabled={!canEdit || sortedIndex === injects.length - 1}
                        className={`px-2 py-1 text-xs bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:opacity-50 text-white rounded ${focusRing}`}
                        title="Move down"
                        aria-label={`Move inject #${inject.number} down`}
                      >
                        Down
                      </button>
                      
                      {/* Complete/Incomplete */}
                      <button
                        onClick={() => handleToggleInjectStatus(inject.id)}
                        disabled={!canEdit || inject.status === 'skipped'}
                        className={`px-2 py-1 text-xs font-semibold rounded transition-colors disabled:opacity-50 ${focusRing} ${
                          inject.status === 'completed' 
                            ? 'bg-orange-600 hover:bg-orange-700 text-white' 
                            : 'bg-green-600 hover:bg-green-700 text-white'
                        }`}
                        title={inject.status === 'completed' ? 'Mark incomplete' : 'Mark complete'}
                        aria-label={inject.status === 'completed' ? `Mark inject #${inject.number} incomplete` : `Mark inject #${inject.number} complete`}
                      >
                        {inject.status === 'completed' ? 'Undo' : 'Done'}
                      </button>
                      {/* Skip */}
                      <button
                        onClick={() => handleSkipInject(inject.id)}
                        disabled={!canEdit || inject.status === 'skipped' || inject.status === 'completed'}
                        className={`px-2 py-1 text-xs bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:opacity-50 text-white rounded ${focusRing}`}
                        title="Skip inject"
                        aria-label={`Skip inject #${inject.number}`}
                      >
                        Skip
                      </button>
                      {/* Delete */}
                      <button
                        onClick={() => handleDeleteInject(inject.id)}
                        className={`px-2 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded ${focusRing}`}
                        disabled={!canEdit}
                        title="Delete inject"
                        aria-label={`Delete inject #${inject.number}`}
                      >
                        Delete
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    )
  }

  const ResourceRequestBoard = () => {
    const [editingResource, setEditingResource] = useState<string | null>(null)
    const [editETA, setEditETA] = useState('')

    const handleStartEdit = (resource: ResourceItem) => {
      setEditingResource(resource.id)
      setEditETA(formatHMS(resource.etaSeconds))
    }

    const handleSaveEdit = (resourceId: string) => {
      handleResourceETAEdit(resourceId, editETA)
      setEditingResource(null)
      setEditETA('')
    }

    const handleCancelEdit = () => {
      setEditingResource(null)
      setEditETA('')
    }

    return (
      <div className="bg-gray-800 rounded-lg p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-2xl font-bold text-white">Resource Requests</h3>
          <div className="flex items-center gap-3">
            <label className="flex items-center gap-2 text-sm text-gray-300">
              <input type="checkbox" checked={autoAdvanceResources} onChange={(e)=>setAutoAdvanceResources(e.target.checked)} />
              Auto-advance
            </label>
            <button
              onClick={() => {
                // Import-ready CSV: minutes instead of absolute seconds
                const rows: (string|number)[][] = []
                rows.push(['Label','Kind','ETA (minutes)','Status'])
                const sorted = [...resources].sort((a,b) => a.etaSeconds - b.etaSeconds)
                sorted.forEach(r => {
                  const minutes = Math.max(0, Math.round((r.etaSeconds - currentSeconds) / 60))
                  rows.push([r.label, r.kind || '', minutes, r.status])
                })
                const name = exerciseName?.trim() ? `_${exerciseName.trim().replace(/\s+/g,'_')}` : ''
                downloadCSV(`resources_import${name}.csv`, rows)
              }}
              className="p-2 rounded bg-gray-700 hover:bg-gray-600 text-white"
              title="Export Resources (Import CSV)"
              aria-label="Export Resources (Import CSV)"
            >
              <FileDown className="w-4 h-4" />
            </button>
            <button
              onClick={() => { if (typeof window !== 'undefined') window.open('/display/resources', 'ResourcesDisplay', 'noopener,noreferrer,width=1200,height=800'); }}
              className="p-2 rounded bg-gray-700 hover:bg-gray-600 text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-400 focus-visible:ring-offset-2 ring-offset-gray-800"
              title="Open Resources Display"
              aria-label="Open Resources Display"
            >
              <ExternalLink className="w-4 h-4" />
            </button>
          </div>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full" aria-label="Resource requests table">
            <thead className="bg-gray-700">
              <tr>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Label</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">ETA</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Status</th>
                <th className="px-4 py-3 text-left text-sm font-semibold text-white">Actions</th>
              </tr>
            </thead>
            <tbody>
              {resources.map((resource) => (
                <tr key={resource.id} className="border-t border-gray-600">
                  <td className="px-4 py-3 text-sm text-white">
                    <span className="inline-flex items-center gap-2">
                      {getResourceStatusIcon(resource.status)}
                      {resource.kind && <span className="opacity-80">{getResourceKindIcon(resource.kind)}</span>}
                      <span>{resource.label}</span>
                    </span>
                  </td>
                  <td className="px-4 py-3 text-sm font-mono text-white">
                    {editingResource === resource.id ? (
                      <div className="flex gap-2 items-center">
                        <input
                          type="text"
                          value={editETA}
                          onChange={(e) => setEditETA(e.target.value)}
                          className="px-2 py-1 bg-gray-700 text-white rounded text-xs font-mono w-20"
                          placeholder="HH:MM:SS"
                        />
                        <button
                          onClick={() => handleSaveEdit(resource.id)}
                          className="px-2 py-1 bg-green-600 hover:bg-green-700 text-white text-xs rounded"
                        >
                          Save
                        </button>
                        <button
                          onClick={handleCancelEdit}
                          className="px-2 py-1 bg-gray-600 hover:bg-gray-700 text-white text-xs rounded"
                        >
                          Cancel
                        </button>
                      </div>
                    ) : (
                      <span
                        className={`cursor-pointer ${canEdit ? 'hover:text-blue-400' : 'text-gray-400 cursor-not-allowed'}`}
                        onClick={() => { if (canEdit) handleStartEdit(resource) }}
                        title={canEdit ? "Click to edit ETA" : "Editing locked"}
                      >
                        {formatHMS(resource.etaSeconds)}
                      </span>
                    )}
                  </td>
                  <td className="px-4 py-3">
                    <span className={`px-2 py-1 rounded-full text-xs font-semibold capitalize ${getResourceStatusColor(resource.status)}`}>
                      {resource.status}
                    </span>
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex gap-1 flex-wrap">
                      {resource.status === "requested" && (
                        <button
                          onClick={() => handleResourceStatusChange(resource.id, "tasked")}
                          className="px-2 py-1 text-xs bg-amber-600 hover:bg-amber-700 disabled:bg-gray-600 text-white rounded"
                          disabled={!canEdit}
                        >
                          Task
                        </button>
                      )}
                      {resource.status === "tasked" && (
                        <button
                          onClick={() => handleResourceStatusChange(resource.id, "enroute")}
                          className="px-2 py-1 text-xs bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white rounded"
                          disabled={!canEdit}
                        >
                          Dispatch
                        </button>
                      )}
                      {resource.status === "enroute" && (
                        <button
                          onClick={() => handleResourceStatusChange(resource.id, "arrived")}
                          className="px-2 py-1 text-xs bg-green-600 hover:bg-green-700 disabled:bg-gray-600 text-white rounded"
                          disabled={!canEdit}
                        >
                          Arrive
                        </button>
                      )}
                      {!isTerminalStatus(resource.status) && (
                        <button
                          onClick={() => handleResourceStatusChange(resource.id, "cancelled")}
                          className="px-2 py-1 text-xs bg-red-600 hover:bg-red-700 disabled:bg-gray-600 text-white rounded"
                          disabled={!canEdit}
                        >
                          Cancel
                        </button>
                      )}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
          {resources.length === 0 && (
            <div className="text-center py-8 text-gray-400">No resources added yet</div>
          )}
        </div>
      </div>
    )
  }

  // Main render
  return (
    <div className="min-h-screen bg-gray-900 text-white p-6">
      <div className="max-w-7xl mx-auto space-y-6">
        <ExerciseHeader
          exerciseName={exerciseName}
          controllerName={controllerName}
          exerciseFinishTime={exerciseFinishTime}
          onExerciseNameChange={handleExerciseNameChange}
          onControllerNameChange={handleControllerNameChange}
          onFinishTimeChange={handleFinishTimeChange}
          readonly={!canEdit}
        />

        <ExerciseOverview
          exerciseName={exerciseName}
          controllerName={controllerName}
        />

        {/* Full-width timer for clear layout */}
        <TimerControls />

        {/* Timeline filters above status lists */}
        <div className="space-y-4">
          <Timeline\n              currentSeconds={currentSeconds}\n              finishSeconds={(typeof exerciseFinishTime === 'string' && exerciseFinishTime) ? (parseHMS(exerciseFinishTime) ?? undefined) : undefined}\n              injects={injects.filter((i) => {\n                if (i.type === 'in person' && !showInPerson) return false\n                if (i.type === 'radio/phone' && !showRadioPhone) return false\n                if (i.type === 'electronic' && !showElectronic) return false\n                if (i.type === 'map inject' && !showMapInject) return false\n                if (i.type === 'other' && !showOther) return false\n                return true\n              })}\n              resources={resources.filter((r) => {\n                if (r.status === 'requested' && !showRequestedStatus) return false\n                if (r.status === 'tasked' && !showTaskedStatus) return false\n                if (r.status === 'enroute' && !showEnrouteStatus) return false\n                if (r.status === 'arrived' && !showArrivedStatus) return false\n                if (r.status === 'cancelled' && !showCancelledStatus) return false\n                return true\n              })}\n            />

          
          {showInjects && (
            <Timeline\n              currentSeconds={currentSeconds}\n              finishSeconds={(typeof exerciseFinishTime === 'string' && exerciseFinishTime) ? (parseHMS(exerciseFinishTime) ?? undefined) : undefined}\n              injects={injects.filter((i) => {\n                if (i.type === 'in person' && !showInPerson) return false\n                if (i.type === 'radio/phone' && !showRadioPhone) return false\n                if (i.type === 'electronic' && !showElectronic) return false\n                if (i.type === 'map inject' && !showMapInject) return false\n                if (i.type === 'other' && !showOther) return false\n                return true\n              })}\n              resources={resources.filter((r) => {\n                if (r.status === 'requested' && !showRequestedStatus) return false\n                if (r.status === 'tasked' && !showTaskedStatus) return false\n                if (r.status === 'enroute' && !showEnrouteStatus) return false\n                if (r.status === 'arrived' && !showArrivedStatus) return false\n                if (r.status === 'cancelled' && !showCancelledStatus) return false\n                return true\n              })}\n            />
          )}

          {showInjects && <InjectList />}
        </div>

        {/* Forms at bottom to leave space for status lists */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <AddInjectForm
            onAddInject={handleAddInjectCallback}
            onImportClick={handleImportClickCallback}
            disabled={!canEdit}
          />

          <AddResourceForm
            onAddResource={handleAddResourceCallback}
            onImportClick={handleResourceImportClickCallback}
            disabled={!canEdit}
          />
        </div>
      </div>

      {/* Import Modals */}
      <ImportInjectsModal
        open={injectImport.open}
        onClose={() => injectImport.setOpen(false)}
        isProcessing={injectImport.isProcessing}
        importMode={injectImport.importMode}
        setImportMode={injectImport.setImportMode}
        importFile={injectImport.importFile}
        onFileSelect={injectImport.onFileSelect}
        onClearFile={injectImport.clearFile}
        validationErrors={injectImport.validationErrors}
        invalidRows={injectImport.invalidInjectRows}
        previewInjects={injectImport.previewInjects}
        onImport={injectImport.commitImport}
        onDownloadTemplate={injectImport.downloadTemplate}
        getInjectTypeColor={getInjectTypeColor}
      />
      <ImportResourcesModal
        open={resourceImport.open}
        onClose={() => resourceImport.setOpen(false)}
        isProcessing={resourceImport.isProcessing}
        importMode={resourceImport.importMode}
        setImportMode={resourceImport.setImportMode}
        importFile={resourceImport.importFile}
        onFileSelect={resourceImport.onFileSelect}
        onClearFile={resourceImport.clearFile}
        validationErrors={resourceImport.validationErrors}
        invalidRows={resourceImport.invalidResourceRows}
        previewResources={resourceImport.previewResources}
        onImport={resourceImport.commitImport}
        currentSeconds={currentSeconds}
      />

      {/* Toast for remote updates */}
      {toast && (
        <div className="fixed bottom-4 right-4 bg-gray-800 border border-gray-700 text-white px-3 py-2 rounded shadow">
          {toast.message}
        </div>
      )}
    </div>
  )
}





